// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: items.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const countItemsByMerchant = `-- name: CountItemsByMerchant :one
SELECT COUNT(*)
FROM items
WHERE merchant_id = $1
  AND ($2::uuid = '00000000-0000-0000-0000-000000000000'::uuid OR id = $2::uuid)
  AND ($3::text = '' OR name ILIKE '%' || $3::text || '%')
  AND ($4::text = '' OR product_category = $4::text)
`

type CountItemsByMerchantParams struct {
	MerchantID      uuid.UUID `json:"merchant_id"`
	ItemID          uuid.UUID `json:"item_id"`
	Name            string    `json:"name"`
	ProductCategory string    `json:"product_category"`
}

func (q *Queries) CountItemsByMerchant(ctx context.Context, arg CountItemsByMerchantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countItemsByMerchant,
		arg.MerchantID,
		arg.ItemID,
		arg.Name,
		arg.ProductCategory,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
    merchant_id,
    name,
    product_category,
    price,
    image_url
) VALUES (
    $1::uuid,
    $2::text,
    $3::text,
    $4::bigint,
    $5::text
)
RETURNING id
`

type CreateItemParams struct {
	Merchantid      uuid.UUID `json:"merchantid"`
	Name            string    `json:"name"`
	Productcategory string    `json:"productcategory"`
	Price           int64     `json:"price"`
	Imageurl        string    `json:"imageurl"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.Merchantid,
		arg.Name,
		arg.Productcategory,
		arg.Price,
		arg.Imageurl,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listItemsByMerchant = `-- name: ListItemsByMerchant :many
SELECT id, merchant_id, name, product_category, price, image_url, created_at
FROM items
WHERE merchant_id = $1
    AND ($2::uuid = '00000000-0000-0000-0000-000000000000'::uuid OR id = $2::uuid)
    AND ($3::text IS NULL OR $3::text = '' OR name ILIKE '%' || $3::text || '%')
    AND ($4::text IS NULL OR $4::text = '' OR product_category = $4)
ORDER BY
    CASE WHEN $5 = 'asc' THEN created_at END ASC NULLS LAST,
    CASE WHEN $5 = 'desc' THEN created_at END DESC NULLS LAST,
    created_at DESC
LIMIT $7 OFFSET $6
`

type ListItemsByMerchantParams struct {
	MerchantID      uuid.UUID   `json:"merchant_id"`
	ItemID          uuid.UUID   `json:"item_id"`
	Name            string      `json:"name"`
	ProductCategory string      `json:"product_category"`
	CreatedAtOrder  interface{} `json:"created_at_order"`
	Offsetpage      int32       `json:"offsetpage"`
	Limitpage       int32       `json:"limitpage"`
}

func (q *Queries) ListItemsByMerchant(ctx context.Context, arg ListItemsByMerchantParams) ([]Items, error) {
	rows, err := q.db.Query(ctx, listItemsByMerchant,
		arg.MerchantID,
		arg.ItemID,
		arg.Name,
		arg.ProductCategory,
		arg.CreatedAtOrder,
		arg.Offsetpage,
		arg.Limitpage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Items{}
	for rows.Next() {
		var i Items
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.ProductCategory,
			&i.Price,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const merchantExists = `-- name: MerchantExists :one
SELECT EXISTS(SELECT 1 FROM merchants WHERE id = $1)
`

func (q *Queries) MerchantExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, merchantExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
